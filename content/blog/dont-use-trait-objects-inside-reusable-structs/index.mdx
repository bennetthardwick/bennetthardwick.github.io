---
title: Don't use boxed trait objects in struct internals
byline: ...
tags: [rust,beginner]
slug: dont-use-trait-objects-inside-reusable-components
comments: true
---

As a software developer you're constantly told to stop re-inventing the wheel. 

This is fantastic advice and something that I try and follow 80% of the time.
However, there's often times in Rust where I back myself into a corner that I can't get out of without rewriting a whole lot of code.

One such problem that I encountered recently, was working with boxed trait objects - `Box<dyn Trait>`.

### What's a `Trait`?

According to the [rust book](https://doc.rust-lang.org/book/ch10-02-traits.html), traits are Rust's method for defining shared behaviour. 
Much like interfaces in other languages, Rust traits are a method of abstraction that allows you to define a schema through which you can
communicate with an object - [and a lot more](https://blog.rust-lang.org/2015/05/11/traits.html).

### Boxed trait objects

However, since the size of a trait is not known at compile time (anything can implement a trait, no matter what size) it's hard to store
an object based on the trait it implements since the compiler doesn't know exactly how much space to make available.
Rust's solution to this, is to put a trait inside a `Box`, `Arc` or `Rc` and store the container instead.

This is a very useful feature which allows you to do all kinds of awesome stuff - like creating vectors of traits of unknown sizes.

However, like all things, this typically comes at a cost. Especially when designing a `struct` that will be consumed by different developers with
unknown and evolving use cases.

## Problems with an interior `Box<dyn Trait>`

Say I had a trait that depicted a person.
I might create a method inside that trait that allows the person to `say_hello`.

```rust
trait Person {
  fn say_hello(&self);
}
```

It would be super easy to implement and allow each different person to say hello in their own favourite greeting.

Now my requirements for the people have changed, and I need to group them together in a `PeopleZoo`.
Typically I might model this using a vector of boxed trait objects.

```rust
struct PeopleZoo {
  people: Vec<Box<dyn Person>>
}

impl PeopleZoo {
  fn add_person(&mut self, person: Box<dyn Person>) {
    self.people.push(person);
  }

  fn last_person(&self) -> Option<&Person> {
    self.people.last()
  }
}
```

This would work great in most cases.
It allows each `Person` to say their own greeting and be stored in the same vector.

I can even create my own structs and begin adding people into the zoo.

```rust
struct Me {
  name: &'static str
}

impl Person for Me {
  fn say_hello(&self) {
    println!("Hello, it's me.");
  }
}

```

However, this starts to fall apart as soon as I begin to do anything complex.
For example, if I wanted to get the last person added into the zoo and if they're "Me" check what their name is.

```rust
let mut zoo: PeopleZoo = PeopleZoo { people: vec![] };
zoo.add_person(Box::new(Me { name: "Bennett" }));

// How can I figure out that this is "Me"?
let person = zoo.last_person().unwrap();
```

Unfortunately this is where it gets complex.

// First we would have to update our trait to include

```rust
trait Person {
    fn say_hello(&self);
    fn as_any(&self) -> &dyn Any;
}
```

// then we would have to update every struct that implements this trait to have the as_any method

```rust
impl Person for Me {
    fn say_hello(&self) {
        println!("Hello, it's me.")
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
```

// Finally, we would have to execute a long chain of functions to get back to our original type.

```rust
let mut zoo: PeopleZoo<Me> = PeopleZoo { people: vec![] };
zoo.add_person(Me { name: "Bennett" });

let me: &Me = zoo
    .last_person()
    .unwrap()
    .as_ref()
    .as_any()
    .downcast_ref::<Me>()
    .unwrap();
```
[Full Example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f4a5360fec6f40b7c68216214a52f060)

It doesn't seem very nice, fortunately there is a solution.


## Generics

// I shouldn't have to worry about the trait having all the information I need to find my value again, it's not the traits responsibility.
// the responsibility of the trait is to do the work of what it says it is - and I can't trust that every trait that is created will have
// the necessary `as_any` field that I need.
// Therefore, if i'm using a trait it's up to me to make sure I can do all I need with it

// Firstly, update `PeopleZoo` to use generics

```rust
struct PeopleZoo<P: Person> {
    people: Vec<P>,
}

impl<P: Person> PeopleZoo<P> {
    fn add_person(&mut self, person: P) {
        self.people.push(person);
    }

    fn last_person(&self) -> Option<&P> {
        self.people.last()
    }
}
```

Next, remove the `as_any` calls from the traits and implementation. This then allows you to simplify the calls to get people from the zoo.

```rust
let mut zoo: PeopleZoo<Me> = PeopleZoo { people: vec![] };
zoo.add_person(Me { name: "Bennett" });

let me: &Me = zoo
    .last_person()
    .unwrap();
```
[Full Example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=59c28f6fa71b2bf7888dca26b6f30854)


Our code is a lot simpler now, but unfortunately we've lost a lot of flexibility.
The previous version of `PeopleZoo` allowed any arbitrary number of objects implementing the
`Person` trait.

## Enum Wrappers for Trait Objects

// Create another type to be used

```rust
struct Grandma {
    age: usize
}

impl Person for Grandma {
    fn say_hello(&self) {
        println!("G'day!")
    }
}
```

// Now create an enum which contains all the types
// Enums in rust are tagged unions, which means they take up the space of the largest
// entry in the enum, plus a few extra bytes for information about what they are.
// This means they don't need to be heap allocated like a Box would

```rust
enum People {
    Grandma(Grandma),
    Me(Me)
}

impl Person for People {
    fn say_hello(&self) {
        match self {
            People::Grandma(grandma) => grandma.say_hello(),
            People::Me(me) => me.say_hello()
        }
    }
}
```

// With a few modifications it can be used just like before

```rust
let mut zoo: PeopleZoo<People> = PeopleZoo { people: vec![] };
zoo.add_person(People::Me(Me { name: "Bennett" }));

if let Some(People::Me(me)) = zoo.last_person() {
    println!("My name is {}.", me.name)
}
```

[Full Example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=501693ad07bda2f1e83dc31d230f8a8a)

This gives the person who is consuming `PeopleZoo` the most flexibility.

## Using `Box<dyn Trait>`

// I'm not saying that using boxed trait objects is bad, just that it gives other developers consuming your struct
// a hard time since there's not much flexibility. You should leave it up to however uses your struct to choose
// to use Box<dyn Trait/>.


### A `Box<dyn Trait>` trick

// By default a `Box<dyn Trait>` doesn't implement the trait of the trait object that it contains.
// This means that trying to construct `PeopleZoo<Box<dyn Person>>` will give a type error. 
// Because of this, it's good practice to give a default implementation of your trait for it's boxed
// version. This is done by calling `as_ref` or `as_mut` on the `Box` and calling then calling the
// relevant method. This small bit of effort will help a bunch of people that consume your struct.

```rust
trait Person {
    fn say_hello(&self);
}

impl Person for Box<dyn Person> {
    fn say_hello(&self) {
        self.as_ref().say_hello()
    }
}

fn main() {
  let mut zoo: PeopleZoo<Box<dyn Person>> = PeopleZoo { people: vec![] };
}
```

## Conclusion

// Box traits make it really hard to get the original value back again.  
// If a developer of a crate doesn't give a way for you to cast to any, you won't be able to get the original value back.  
// Using generics you can let the user decide what type it should be - as long as they implement the trait.  
// You can use enums to limit heap allocations and make it easier to find the original type,   
// at the expense of greater memory consumption and slightly more code 
